name: Auto Release to GitHub Packages

on:
  push:
    branches:
      - main
    paths:
      - 'packages/**'
      - 'tooling/**'
      - 'sdk/**'

permissions:
  contents: write
  packages: write
  id-token: write

jobs:
  detect-changes:
    name: Detect Changed Packages
    runs-on: ubuntu-latest
    outputs:
      changed_packages: ${{ steps.detect.outputs.packages }}
      has_changes: ${{ steps.detect.outputs.has_changes }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Detect changed packages
        id: detect
        run: |
          # Get changed files in the last commit
          CHANGED_FILES=$(git diff --name-only HEAD^ HEAD)
          echo "Changed files:"
          echo "$CHANGED_FILES"

          # Find unique package directories that changed
          PACKAGES=$(echo "$CHANGED_FILES" | \
            grep -E '^(packages|tooling|sdk)/' | \
            cut -d'/' -f1,2,3 | \
            sort -u | \
            while read dir; do
              # Find the nearest package.json
              if [ -f "$dir/package.json" ]; then
                echo "$dir"
              else
                # For nested packages like packages/framework/framework
                parent_dir=$(echo "$dir" | cut -d'/' -f1,2)
                if [ -f "$parent_dir/package.json" ]; then
                  echo "$parent_dir"
                fi
              fi
            done | sort -u)

          if [ -z "$PACKAGES" ]; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "packages=[]" >> $GITHUB_OUTPUT
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
            # Convert to JSON array
            JSON_ARRAY=$(echo "$PACKAGES" | jq -R -s -c 'split("\n") | map(select(length > 0))')
            echo "packages=$JSON_ARRAY" >> $GITHUB_OUTPUT
            echo "Changed packages: $JSON_ARRAY"
          fi

  release:
    name: Release Package
    needs: detect-changes
    if: needs.detect-changes.outputs.has_changes == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        package: ${{ fromJson(needs.detect-changes.outputs.changed_packages) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.20.0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'
          registry-url: 'https://npm.pkg.github.com'
          scope: '@osome'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Get package info
        id: package_info
        working-directory: ${{ matrix.package }}
        run: |
          PACKAGE_NAME=$(node -p "require('./package.json').name")
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          echo "name=$PACKAGE_NAME" >> $GITHUB_OUTPUT
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "Package: $PACKAGE_NAME@$CURRENT_VERSION"

      - name: Bump version (patch)
        id: bump_version
        working-directory: ${{ matrix.package }}
        run: |
          # Bump patch version
          npm version patch -m "chore(release): %s [skip ci]" --no-git-tag-version
          NEW_VERSION=$(node -p "require('./package.json').version")
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "Bumped version to $NEW_VERSION"

      - name: Build package
        working-directory: ${{ matrix.package }}
        run: |
          # Run build if build script exists
          if node -p "require('./package.json').scripts?.build" 2>/dev/null | grep -v undefined; then
            pnpm build
          else
            echo "No build script found, skipping build"
          fi

      - name: Configure npm for GitHub Packages
        working-directory: ${{ matrix.package }}
        run: |
          # Update package.json to include publishConfig
          node -e "
          const fs = require('fs');
          const pkg = JSON.parse(fs.readFileSync('./package.json', 'utf8'));
          pkg.publishConfig = {
            registry: 'https://npm.pkg.github.com/',
            access: 'restricted'
          };
          if (pkg.name && !pkg.name.startsWith('@')) {
            console.error('Package name must be scoped (e.g., @osome/package-name)');
            process.exit(1);
          }
          fs.writeFileSync('./package.json', JSON.stringify(pkg, null, 2) + '\n');
          "

      - name: Publish to GitHub Packages
        working-directory: ${{ matrix.package }}
        env:
          NODE_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Publishing ${{ steps.package_info.outputs.name }}@${{ steps.bump_version.outputs.new_version }}"
          pnpm publish --no-git-checks --access restricted

      - name: Commit version bump
        run: |
          git add "${{ matrix.package }}/package.json"
          git commit -m "chore(release): ${{ steps.package_info.outputs.name }}@${{ steps.bump_version.outputs.new_version }} [skip ci]" || echo "No changes to commit"
          git push origin main || echo "Nothing to push"

      - name: Create Git tag
        run: |
          TAG_NAME="${{ steps.package_info.outputs.name }}@${{ steps.bump_version.outputs.new_version }}"
          git tag -a "$TAG_NAME" -m "Release $TAG_NAME"
          git push origin "$TAG_NAME"

      - name: Create GitHub Release
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const tagName = `${{ steps.package_info.outputs.name }}@${{ steps.bump_version.outputs.new_version }}`;
            const packageName = '${{ steps.package_info.outputs.name }}';
            const version = '${{ steps.bump_version.outputs.new_version }}';

            await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: tagName,
              name: `${packageName}@${version}`,
              body: `Released ${packageName} version ${version}\n\nPackage: \`${packageName}\`\nVersion: \`${version}\`\n\nInstall with:\n\`\`\`bash\nnpm install ${packageName}@${version}\n\`\`\``,
              draft: false,
              prerelease: false
            });
